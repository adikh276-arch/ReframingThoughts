import React, { createContext, useContext, useState, useEffect, useCallback } from "react";
import { lingo } from "@/lib/lingo";

export const MAJOR_LOCALES = [
    { code: "en", name: "English" },
    { code: "es", name: "Español" },
    { code: "fr", name: "Français" },
    { code: "de", name: "Deutsch" },
    { code: "hi", name: "हिन्दी" },
    { code: "zh", name: "中文" },
    { code: "ja", name: "日本語" },
    { code: "ko", name: "한국어" },
    { code: "pt", name: "Português" },
    { code: "it", name: "Italiano" },
    { code: "ru", name: "Русский" },
    { code: "ar", name: "العربية" },
    { code: "bn", name: "বাংলা" },
];

type TranslationContextType = {
    locale: string;
    setLocale: (locale: string) => void;
    translate: (text: string) => Promise<string>;
    loading: boolean;
};

const TranslationContext = createContext<TranslationContextType | undefined>(undefined);

export const TranslationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [locale, setLocaleState] = useState(() => {
        const searchParams = new URLSearchParams(window.location.search);
        return searchParams.get("lang") || "en";
    });
    const [translations, setTranslations] = useState<Record<string, string>>({});
    const [loading, setLoading] = useState(false);

    // Load static translations from local files (generated by CI/CD)
    useEffect(() => {
        if (locale === "en") {
            setTranslations({});
            return;
        }

        const loadTranslations = async () => {
            try {
                // Adjust path based on your deployment structure
                const response = await fetch(`/reframing-thoughts/src/locales/${locale}.json`);
                if (response.ok) {
                    const data = await response.json();
                    // Flatten translations if nested
                    const flattened: Record<string, string> = {};
                    const flatten = (obj: any, prefix = "") => {
                        for (const key in obj) {
                            const val = obj[key];
                            if (typeof val === "string") {
                                flattened[prefix + key] = val;
                            } else {
                                flatten(val, prefix + key + ".");
                            }
                        }
                    };
                    flatten(data);
                    setTranslations(flattened);
                }
            } catch (err) {
                console.warn(`Could not load local translations for ${locale}, falling back to SDK live translation.`);
            }
        };

        loadTranslations();
    }, [locale]);

    const setLocale = (newLocale: string) => {
        setLocaleState(newLocale);
        const url = new URL(window.location.href);
        url.searchParams.set("lang", newLocale);
        window.history.pushState({}, "", url);
    };

    const translate = useCallback(
        async (text: string) => {
            if (locale === "en" || !text) return text;

            // 1. Try local translations first (CORS-free)
            if (translations[text]) return translations[text];

            // 2. Fallback to Lingo.dev SDK (Live AI Translation)
            try {
                const result = await lingo.localizeText(text, {
                    sourceLocale: "en",
                    targetLocale: locale,
                });
                return result;
            } catch (error) {
                console.error("Translation error (SDK):", error);
                return text;
            }
        },
        [locale, translations]
    );

    return (
        <TranslationContext.Provider value={{ locale, setLocale, translate, loading }}>
            {children}
        </TranslationContext.Provider>
    );
};

export const T: React.FC<{ children: string }> = ({ children }) => {
    const [translated, setTranslated] = useState(children);
    const { translate, locale } = useTranslation();

    useEffect(() => {
        let isMounted = true;
        translate(children).then((res) => {
            if (isMounted) setTranslated(res);
        });
        return () => {
            isMounted = false;
        };
    }, [children, locale, translate]);

    return <>{translated}</>;
};

export const useTranslation = () => {
    const context = useContext(TranslationContext);
    if (!context) {
        throw new Error("useTranslation must be used within a TranslationProvider");
    }
    return context;
};
